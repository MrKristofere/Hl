name: Download and Process Files
on:
  workflow_dispatch:
    inputs:
      upl:
        description: 'Comma-separated list of URLs'
        required: true
        type: string
      tag:
        description: 'Tag for GitHub release'
        required: true
        type: string
      parallel_downloads:
        description: 'Number of parallel downloads'
        required: true
        type: string
      upload_destination:
        description: 'Where to upload files (GitHub or Telegram or both)'
        required: true
        type: choice
        options:
          - github
          - telegram
          - both

permissions:
  contents: write

jobs:
  download:
    runs-on: ubuntu-latest
    steps:
      - name: Setup
        run: |
          sudo apt-get update
          sudo apt-get install -y aria2 curl unzip p7zip-full jq
          mkdir -p dloa  # Создаем каталог для загрузки

      - name: Validate input URLs
        run: |
          if [ -z "${{ inputs.upl }}" ]; then
            echo "Ошибка: не переданы URL для загрузки."
            exit 1
          fi

      - name: Validate parallel_downloads
        run: |
          # Проверяем, что количество параллельных загрузок — это целое число больше 0
          if ! [[ "${{ inputs.parallel_downloads }}" =~ ^[0-9]+$ ]] || [ "${{ inputs.parallel_downloads }}" -le 0 ]; then
            echo "Ошибка: параметр parallel_downloads должен быть положительным числом."
            exit 1
          fi

      - name: Prepare URL list
        run: |
          # Убираем лишние пробелы перед и после запятых
          CLEANED_URLS=$(echo "${{ inputs.upl }}" | sed 's/ \+/ /g' | sed 's/ ,/,/g')
          IFS=',' read -ra URLS <<< "$CLEANED_URLS"
          echo "Количество URL: ${#URLS[@]}"

      - name: URL Encoding Function
        run: |
          encode_url() {
            echo "$1" | jq -sRr @uri
          }
          export -f encode_url

      - name: Download files
        run: |
          MAX_PARALLEL_DOWNLOADS=${{ inputs.parallel_downloads }}  # Получаем количество параллельных загрузок
          RETRIES=3  # Максимальное количество попыток загрузки
          INITIAL_DELAY=2  # Начальная задержка (сек)
          
          download_with_retries() {
            url=$1
            retries=0
            encoded_url=$(encode_url "$url")  # Кодируем URL

            until aria2c -d dloa -x 16 -s 16 --continue=true "$encoded_url"; do
              if (( retries >= RETRIES )); then
                echo "Ошибка: не удалось скачать файл $encoded_url после $RETRIES попыток."
                return 1
              fi
              retries=$((retries + 1))
              sleep_time=$((INITIAL_DELAY ** retries))  # Экспоненциальная задержка
              echo "Попытка скачивания $encoded_url не удалась. Повторная попытка ($retries из $RETRIES). Ожидание $sleep_time секунд."
              sleep $sleep_time
            done
            return 0
          }

          COUNTER=0
          for url in "${URLS[@]}"; do
            download_with_retries "$url" &  # Запускаем скачивание в фоновом режиме
            COUNTER=$((COUNTER + 1))

            # Управляем количеством параллельных загрузок
            if (( COUNTER >= MAX_PARALLEL_DOWNLOADS )); then
              echo "Достигнут лимит параллельных загрузок ($MAX_PARALLEL_DOWNLOADS), ожидаем завершения..."
              wait  # Ожидаем завершения всех параллельных загрузок
              COUNTER=0  # Сброс счётчика параллельных загрузок
            fi
          done
          wait  # Ожидаем завершения всех оставшихся параллельных загрузок

      - name: Extract and check CRC32 for downloaded files
        run: |
          extract_with_retries() {
            file=$1
            retries=0
            until [ -f "$file" ]; do
              if (( retries >= 3 )); then
                echo "Ошибка: файл $file не существует или поврежден. Пропускаем."
                return 1
              fi
              retries=$((retries + 1))
              echo "Попытка извлечения файла $file не удалась. Повторная попытка ($retries из 3)."
              sleep 2
            done

            if [[ "$file" =~ \.zip$ ]]; then
              unzip -q "$file" -d dloa/
            elif [[ "$file" =~ \.tar\.gz$ ]]; then
              tar -xzvf "$file" -C dloa/
            elif [[ "$file" =~ \.tar$ ]]; then
              tar -xvf "$file" -C dloa/
            elif [[ "$file" =~ \.rar$ ]]; then
              7z x "$file" -odloa
            else
              echo "Неизвестный формат файла для разархивации: $file"
              return 1
            fi
            rm "$file"  # Удаляем оригинальный архив
            return 0
          }

          for file in dloa/*; do
            if [ -f "$file" ]; then
              extract_with_retries "$file"
              # Проверка CRC32 хеша для каждого скачанного файла
              FILE_CRC32=$(crc32 "$file")
              echo "CRC32 для файла $file: $FILE_CRC32"
            fi
          done

      - name: Create Release if it does not exist
        run: |
          if ! gh release view "${{ inputs.tag }}" > /dev/null 2>&1; then
            echo "Релиз с тегом ${{ inputs.tag }} не найден. Создаю новый релиз..."
            gh release create "${{ inputs.tag }}" --title "Release ${inputs.tag}" --notes "Release notes" --target main
          else
            echo "Релиз ${{ inputs.tag }} уже существует."
          fi

      - name: Upload files to GitHub Release
        run: |
          echo "Загружаем файлы в GitHub Release..."
          for file in dloa/*; do
            if [ -f "$file" ]; then
              echo "Загружаем файл: $file"
              gh release upload "${{ inputs.tag }}" "$file" --clobber
            fi
          done

      - name: Upload to Telegram (optional)
        if: ${{ inputs.upload_destination == 'telegram' || inputs.upload_destination == 'both' }}
        run: |
          # Загрузка в Telegram (добавьте ваш токен и ID чата)
          echo "Загружаем в Telegram..."
          curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendDocument" -F document=@dloa/* -F chat_id=${{ secrets.TELEGRAM_CHAT_ID }}

      - name: Final message
        run: |
          echo "Процесс завершён."
