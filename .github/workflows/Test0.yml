name: Upload File (t)

on:
  workflow_dispatch:
    inputs:
      upl:
        description: 'Comma-separated URLs (or GitHub Release assets in the format "owner/repo@tag")'
        required: true
        type: string
      tag:
        description: 'Tag'
        required: true
        type: string
      compression:
        description: 'Compression method'
        required: false
        type: choice
        options:
          - none
          - gzip
          - bzip2
          - xz
          - rar
          - 7z
          - zip
      compress_level:
        description: 'Compression level (1-9)'
        required: false
        type: number
        default:
      checksum:
        description: 'Enable CRC32 checksum verification'
        required: false
        type: boolean
        default: true
      extract:
        description: 'Extract files for verification crc-32'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write
  actions: read

jobs:
  Upload_Files:
    name: 'Upload Files'
    runs-on: ubuntu-latest

    steps:
      - name: Ensure cache directories exist
        run: |
          mkdir -p ~/.cache/pip

      - name: Cache apt dependencies
        id: apt-cache
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: aria2 curl jq unzip p7zip-full crc32 util-linux numfmt rsync zip gzip bzip2 xz-utils parted genisoimage cdrtools tar arj cabextract python3-pip

      - name: Cache Python dependencies
        id: pip-cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/*') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        if: steps.pip-cache.outputs.cache-hit != 'true'
        run: |
          echo "Installing pip dependencies..."
          pip3 install crc32c
          echo "Dependencies installed."

      - name: Download files from URLs and GitHub Releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p dloa
          IFS=',' read -r -a urls <<< "${{ inputs.upl }}"

          download_urls=()

          # Собираем все URL-адреса для параллельной загрузки
          for url in "${urls[@]}"; do
            if [[ "$url" =~ ^[^/]+/[^@]+@.+ ]]; then
              # Скачивание из релиза GitHub, например "owner/repo@tag"
              owner_repo="${url%@*}"
              tag="${url##*@}"
              api_url="https://api.github.com/repos/$owner_repo/releases/tags/$tag"

              # Получение ссылки на артефакты
              assets=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$api_url")
    
              # Проверка, что ответ является валидным JSON
              if ! echo "$assets" | jq . >/dev/null 2>&1; then
                echo "Ошибка при получении данных с API GitHub для $url"
                continue
              fi

              assets=$(echo "$assets" | jq -r '.assets[] | .browser_download_url')

              for asset_url in $assets; do
                real_asset_url=$(curl -Ls -o /dev/null -w '%{url_effective}' "$asset_url")
                download_urls+=("$real_asset_url")
              done
            elif [[ "$url" == *"gofile.io"* ]]; then
              # Для файлов с gofile.io получаем окончательную ссылку через их API
              file_id=$(echo "$url" | grep -oP '(?<=/download/)[^/]+')
              gofile_api="https://api.gofile.io/getUpload?c=$file_id"
    
              # Запрос к API и проверка на успех
              gofile_response=$(curl -s "$gofile_api")
    
              # Проверка, что ответ является валидным JSON
              if ! echo "$gofile_response" | jq . >/dev/null 2>&1; then
                echo "Ошибка при получении данных с API gofile.io для $url"
                continue
              fi
    
              status=$(echo "$gofile_response" | jq -r '.status')
    
              if [[ "$status" == "ok" ]]; then
                real_url=$(echo "$gofile_response" | jq -r '.data.directLink')
                download_urls+=("$real_url")
              else
                echo "Ошибка: Невозможно получить ссылку для загрузки с gofile.io для $url"
              fi
            else
              # Для остальных URL получаем фактический URL через curl
              real_url=$(curl -Ls -o /dev/null -w '%{url_effective}' "$url")
              download_urls+=("$real_url")
            fi
          done

          # Проверяем, были ли добавлены ссылки для загрузки
          if [ ${#download_urls[@]} -eq 0 ]; then
            echo "Ошибка: Не удалось собрать ссылки для загрузки."
            exit 1
          fi

          # Создаём файл со списком прямых ссылок для aria2c
          echo "Downloading files in parallel..."
          printf "%s\n" "${download_urls[@]}" > urls.txt

          # Загрузка файлов с помощью aria2c
          aria2c -i urls.txt -d dloa -x 16 -s 16 --continue=true --auto-file-renaming=false

      - name: Verify downloaded files
        run: |
          ls -lh dloa

      - name: Verify CRC32 checksum
        if: ${{ inputs.checksum == true }}
        run: |
          for file in dloa/*; do
            crc32_value=$(python3 -c "import zlib; print(f'{zlib.crc32(open(\"$file\", \"rb\").read()):08x}')")
            echo "File: $file, CRC32: $crc32_value"
          done

      - name: CRC32 Calculation for Files in Archives and Images
        if: ${{ inputs.extract == true }}
        run: |
          echo "Checking files without extracting..."
          for file in dloa/*; do
            case $file in
              *.tar.*)
                echo "Contents of TAR archive: $file"
                tar -tf "$file" | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(tar -xOf "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.zip)
                echo "Contents of ZIP archive: $file"
                unzip -l "$file" | awk 'NR>3 {print $4}' | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(unzip -p "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.rar)
                echo "Contents of RAR archive: $file"
                7z l "$file" | awk 'NR>1 {print $6}' | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(7z x -so "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.7z)
                echo "Contents of 7z archive: $file"
                7z l "$file" | awk 'NR>1 {print $6}' | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(7z x -so "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.iso)
                echo "Mounting ISO: $file"
                mount_point=$(mktemp -d)
                sudo mount -o loop "$file" "$mount_point"
                find "$mount_point" -type f | while read filepath; do
                  if [[ "$filepath" =~ /[.]/ ]]; then
                    continue
                  fi
                  file_size=$(stat -c %s "$filepath")
                  readable_size=$(numfmt --to=iec --suffix=B "$file_size")
                  crc32_value=$(python3 -c "import zlib, sys; f = open('$filepath', 'rb'); print(f'{zlib.crc32(f.read()) & 0xffffffff:08x}')")
                  echo "File: $filepath, Size: $readable_size ($file_size bytes), CRC32: $crc32_value"
                done
                sudo umount "$mount_point"
                rmdir "$mount_point"
                ;;
              *.img)
                echo "Checking IMG contents: $file"
                mmls "$file" | awk '/\bUnallocated\b/ {next} {print $NF}' | while read partition; do
                  fls -r -p "$file" "$partition" | while read filepath; do
                    if [ -z "$filepath" ]; then
                      continue
                    fi
                    echo "Extracting $filepath from IMG and calculating CRC32"
                    crc32_value=$(icat "$file" "$filepath" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                    if [ "$crc32_value" != "00000000" ]; then
                      echo "File: $filepath, CRC32: $crc32_value"
                    fi
                  done
                done
                ;;
              *)
                echo "Unsupported file type: $file"
                ;;
            esac
          done

      - name: File compression archive
        run: |
          echo "Compressing files..."
          if [ "${{ inputs.compression }}" != "none" ]; then
            case "${{ inputs.compression }}" in
              gzip) tar -cvzf "dloa_compressed.tar.gz" -C dloa . ;;
              bzip2) tar -cvjf "dloa_compressed.tar.bz2" -C dloa . ;;
              xz) tar -cvJf "dloa_compressed.tar.xz" -C dloa . ;;
              rar) 7z a -m0=rar -mx${{ inputs.compress_level }} "dloa_compressed.rar" "dloa/*" ;; 
              7z) 7z a -mx${{ inputs.compress_level }} "dloa_compressed.7z" "dloa/*" ;;
              zip) 7z a -tzip -mx${{ inputs.compress_level }} "dloa_compressed.zip" "dloa/*" ;;
            esac
          else
            echo "No compression selected."
          fi

      - name: Upload to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dloa/*
            dloa_compressed.*
          tag_name: ${{ inputs.tag }}

      - name: Confirm Upload
        run: |
          echo "Files uploaded to GitHub Release."
