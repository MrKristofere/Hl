name: Upload File (t)

on:
  workflow_dispatch:
    inputs:
      upl:
        description: 'Comma-separated URLs (or GitHub Release assets in the format "owner/repo@tag")'
        required: true
        type: string
      tag:
        description: 'Tag'
        required: true
        type: string
      compression:
        description: 'Compression method'
        required: false
        type: choice
        options:
          - none
          - tar
          - gzip
          - bzip2
          - xz
          - rar
          - 7z
          - zip
      compress_level:
        description: 'Compression level (1-9)'
        required: false
        type: string
        default: ''
      checksum:
        description: 'Enable CRC32 checksum verification'
        required: false
        type: boolean
        default: true
      extract:
        description: 'Extract files for verification crc-32'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  id-token: write
  actions: read

jobs:
  Upload_Files:
    name: 'Upload Files'
    runs-on: ubuntu-latest

    steps:
      - name: Ensure cache directories exist
        run: |
          mkdir -p ~/.cache/pip

      - name: Cache apt dependencies
        id: apt-cache
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: aria2 curl jq unzip p7zip-full libarchive-zip-perl util-linux coreutils rsync zip gzip bzip2 xz-utils parted genisoimage cdrtools tar arj cabextract python3-pip

      - name: Cache Python dependencies
        id: pip-cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/*') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        if: steps.pip-cache.outputs.cache-hit != 'true'
        run: |
          echo "Installing pip dependencies..."
          pip3 install crc32c playwright
          echo "Dependencies installed."
      - name: Download files from URLs and GitHub Releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p dloa
          IFS=',' read -r -a urls <<< "${{ inputs.upl }}"

          download_urls=()

          # Собираем все URL-адреса для параллельной загрузки
          for url in "${urls[@]}"; do
            if [[ "$url" =~ ^[^/]+/[^@]+@.+ ]]; then
              # Скачивание из релиза GitHub, например "owner/repo@tag"
              owner_repo="${url%@*}"
              tag="${url##*@}"
              api_url="https://api.github.com/repos/$owner_repo/releases/tags/$tag"

              # Получение ссылки на артефакты
              assets=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$api_url" | jq -r '.assets[] | .browser_download_url')

              for asset_url in $assets; do
                real_asset_url=$(curl -Ls -o /dev/null -w '%{url_effective}' "$asset_url")
                download_urls+=("$real_asset_url")
              done
            else
              # Попытка обычного скачивания с использованием curl
              real_url=$(curl -Ls -o /dev/null -w '%{url_effective}' "$url")
              file_extension="${real_url##*.}"

              # Проверяем, если URL не содержит расширения или это HTML
              content_type=$(curl -s -I "$real_url" | grep -i "Content-Type" | awk '{print $2}' | tr -d '\r')

              if [[ -z "$file_extension" || "$content_type" == "text/html" || "$(curl -s -I "$real_url" | head -n 1)" =~ "HTTP/2 301" || "$(curl -s -I "$real_url" | head -n 1)" =~ "HTTP/2 302" ]]; then
                echo "HTML page detected or file without extension, attempting to download with Playwright..."

                node <<EOF
                const { chromium } = require('playwright');

                (async () => {
                  const browser = await chromium.launch({ headless: true });
                  const page = await browser.newPage();

                  // Устанавливаем заголовки для имитации реального браузера
                  await page.setExtraHTTPHeaders({
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Connection': 'keep-alive',
                   });

                  // Если необходимо, можно добавить cookies
                  await page.context().addCookies([
                    {
                      name: 'session_id',
                      value: 'your_session_id_here',
                      domain: 'example.com',
                      path: '/',
                      httpOnly: true,
                      secure: true,
                    },
                  ]);

                  try {
                    // Пытаемся открыть страницу с ожиданием загрузки всех сетевых запросов
                    await page.goto('$real_url', { waitUntil: 'networkidle', timeout: 60000 });

                    // Если на странице есть кнопка для скачивания, можно добавить взаимодействие:
                    // await page.click('button.download'); // Замените на ваш селектор, если требуется

                    // Получаем URL страницы, на которой производится скачивание
                       const downloadUrl = await page.url();
                       console.log(`Download URL: ${downloadUrl}`);

                    // Ожидаем начала скачивания файла
                       const [download] = await Promise.all([
                      page.waitForEvent('download'),
                      page.click('a') // Замените на ваш селектор для скачивания
                    ]);

                    const filePath = await download.path();
                    console.log('Файл скачан в', filePath);

                  } catch (error) {
                    console.error("Ошибка при скачивании с использованием Playwright:", error);
                  } finally {
                    await browser.close();
                  }
                })();
                EOF
              else
                # Если это прямой URL файла, добавляем его в список для aria2c
                download_urls+=("$real_url")
              fi
            fi
          done

          # Создаём файл со списком прямых ссылок для aria2c
          echo "Downloading files in parallel..."
          printf "%s\n" "${download_urls[@]}" > urls.txt

          # Загрузка файлов с помощью aria2c
          aria2c -i urls.txt -d dloa -x 16 -s 16 --continue=true --auto-file-renaming=false
      
      - name: Verify downloaded files
        run: |
          ls -lh dloa

      - name: Verify CRC32 checksum
        if: ${{ inputs.checksum == true }}
        run: |
          for file in dloa/*; do
            crc32_value=$(python3 -c "import zlib; print(f'{zlib.crc32(open(\"$file\", \"rb\").read()):08x}')")
            echo "File: $file, CRC32: $crc32_value"
          done

      - name: CRC32 Calculation for Files in Archives and Images
        if: ${{ inputs.extract == true }}
        run: |
          echo "Checking files without extracting..."
          for file in dloa/*; do
            case $file in
              *.tar.*)
                echo "Contents of TAR archive: $file"
                tar -tf "$file" | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(tar -xOf "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.zip)
                echo "Contents of ZIP archive: $file"
                unzip -l "$file" | awk 'NR>3 {print $4}' | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(unzip -p "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.rar)
                echo "Contents of RAR archive: $file"
                7z l "$file" | awk 'NR>1 {print $6}' | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(7z x -so "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.7z)
                echo "Contents of 7z archive: $file"
                7z l "$file" | awk 'NR>1 {print $6}' | while read filename; do
                  if [ -z "$filename" ]; then
                    continue
                  fi
                  crc32_value=$(7z x -so "$file" "$filename" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                  if [ "$crc32_value" != "00000000" ]; then
                    echo "File: $filename, CRC32: $crc32_value"
                  fi
                done
                ;;
              *.iso)
                echo "Mounting ISO: $file"
                mount_point=$(mktemp -d)
                sudo mount -o loop "$file" "$mount_point"
                find "$mount_point" -type f | while read filepath; do
                  if [[ "$filepath" =~ /[.]/ ]]; then
                    continue
                  fi
                  file_size=$(stat -c %s "$filepath")
                  readable_size=$(numfmt --to=iec --suffix=B "$file_size")
                  crc32_value=$(python3 -c "import zlib, sys; f = open('$filepath', 'rb'); print(f'{zlib.crc32(f.read()) & 0xffffffff:08x}')")
                  echo "File: $filepath, Size: $readable_size ($file_size bytes), CRC32: $crc32_value"
                done
                sudo umount "$mount_point"
                rmdir "$mount_point"
                ;;
              *.img)
                echo "Checking IMG contents: $file"
                mmls "$file" | awk '/\bUnallocated\b/ {next} {print $NF}' | while read partition; do
                  fls -r -p "$file" "$partition" | while read filepath; do
                    if [ -z "$filepath" ]; then
                      continue
                    fi
                    echo "Extracting $filepath from IMG and calculating CRC32"
                    crc32_value=$(icat "$file" "$filepath" | python3 -c "import zlib, sys; data=sys.stdin.buffer.read(); print(f'{zlib.crc32(data) & 0xffffffff:08x}')")
                    if [ "$crc32_value" != "00000000" ]; then
                      echo "File: $filepath, CRC32: $crc32_value"
                    fi
                  done
                done
                ;;
              *)
                echo "Unsupported file type: $file"
                ;;
            esac
          done

      - name: File compression archive
        run: |
          echo "Compressing files..."
          temp_dir=$(mktemp -d)

          if [ "${{ inputs.compression }}" != "none" ]; then
            for file in dloa/*; do
              filename=$(basename "$file")
              sanitized_filename=$(echo "$filename" | sed 's/[^a-zA-Z0-9._-]/_/g')

              case "${{ inputs.compression }}" in
                gzip) 
                  tar -cvzf "$temp_dir/$sanitized_filename.tar.gz" -${{ inputs.compress_level }} -C dloa "$filename" 
                  ;;
                bzip2) 
                  tar -cvjf "$temp_dir/$sanitized_filename.tar.bz2" -${{ inputs.compress_level }} -C dloa "$filename" 
                  ;;
                xz) 
                  tar -cvJf "$temp_dir/$sanitized_filename.tar.xz" --xz-compress-level=${{ inputs.compress_level }} -C dloa "$filename" 
                  ;;
               rar)  
                  7z a -m0=rar -mx${{ inputs.compress_level }} "$temp_dir/$sanitized_filename.rar" "$file" 
                  ;;
               7z) 
                  7z a -mx${{ inputs.compress_level }} "$temp_dir/$sanitized_filename.7z" "$file" 
                  ;;
               zip) 
                  7z a -tzip -mx${{ inputs.compress_level }} "$temp_dir/$sanitized_filename.zip" "$file" 
                  ;;
                tar) 
                  tar -cvf "$temp_dir/$sanitized_filename.tar" -C dloa "$filename"
                  ;;  
               esac
            done

            echo "Removing original files..."
            rm -rf dloa/*

            echo "Moving compressed files to dloa..."
            mv "$temp_dir"/* dloa/

            rmdir "$temp_dir"
      
          else
            echo "No compression selected."
          fi

      - name: Upload to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dloa/*
          tag_name: ${{ inputs.tag }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Confirm Upload
        run: |
          echo "Files uploaded to GitHub Release under tag: ${{ inputs.tag }}"
